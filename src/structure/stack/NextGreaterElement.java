package structure.stack;

import java.util.Stack;

/**
 * Задача: Следующий больший элемент (Next Greater Element).
 *
 * <p>Вам дан массив целых чисел {@code nums}. Для каждого элемента массива нужно найти следующий
 * больший элемент, который находится справа от этого элемента в массиве. Если для какого-то элемента
 * такого большего элемента нет, то вернуть {@code -1} для этого элемента.</p>
 *
 * <h3>Пример:</h3>
 * <pre>
 *   nums = [4, 5, 2, 10, 8]
 *   Результат: [5, 10, 10, -1, -1]
 * </pre>
 * <ul>
 *   <li>Для {@code 4} следующий больший элемент — это {@code 5}.</li>
 *   <li>Для {@code 5} следующий больший элемент — это {@code 10}.</li>
 *   <li>Для {@code 2} следующий больший элемент — это {@code 10}.</li>
 *   <li>Для {@code 10} нет большего элемента справа, поэтому для него нужно вернуть {@code -1}.</li>
 *   <li>Для {@code 8} также нет большего элемента справа, поэтому для него нужно вернуть {@code -1}.</li>
 * </ul>
 *
 * <h3>Подробное объяснение:</h3>
 * Задача требует найти для каждого элемента массива число, которое больше его и находится дальше по массиву.
 * Если такого числа нет, то для этого элемента возвращается {@code -1}.
 *
 * <p><strong>Простой подход:</strong></p>
 * <p>Для каждого элемента массива {@code nums[i]} пройтись по всем элементам, которые находятся справа от него,
 * и найти первый элемент, который больше {@code nums[i]}. Если такой элемент найден, записываем его в результат;
 * если не найден, записываем {@code -1}. Однако этот подход имеет сложность {@code O(n^2)} (где {@code n} — размер массива),
 * что неэффективно для больших массивов.</p>
 *
 * <p><strong>Оптимизированный подход с использованием стека:</strong></p>
 * <ul>
 *   <li>Используем стек для хранения индексов элементов массива.</li>
 *   <li>Проходим по массиву справа налево (чтобы проще находить следующий больший элемент).</li>
 *   <li>Для каждого элемента проверяем, есть ли в стеке элементы, которые меньше текущего.
 *   Если есть, они уже не могут быть "следующими большими" для каких-либо других элементов, и их можно удалить из стека.</li>
 *   <li>Если стек не пуст, то верхний элемент стека будет "следующим большим" для текущего элемента.</li>
 *   <li>Если стек пуст, значит для текущего элемента нет большего числа справа, и мы записываем {@code -1}.</li>
 * </ul>
 *
 * <h3>Пример пошагового объяснения:</h3>
 * <pre>
 *   nums = [4, 5, 2, 10, 8]
 *   Результат: [5, 10, 10, -1, -1]
 *   1. Начинаем проходить массив с конца.
 *   2. Для элемента {@code 8}: Нет элементов справа, записываем {@code -1}.
 *   3. Для элемента {@code 10}: Нет элементов справа, которые больше {@code 10}, записываем {@code -1}.
 *   4. Для элемента {@code 2}: Следующий больший элемент — {@code 10}, записываем {@code 10}.
 *   5. Для элемента {@code 5}: Следующий больший элемент — {@code 10}, записываем {@code 10}.
 *   6. Для элемента {@code 4}: Следующий больший элемент — {@code 5}, записываем {@code 5}.
 * </pre>
 *
 * <p>Этот подход позволяет найти решение задачи за {@code O(n)} времени и использует дополнительную память для стека.</p>
 */
public class NextGreaterElement {

    /**
     * Метод, который будет решать задачу.
     *
     * @param nums Массив целых чисел для обработки.
     * @return Массив с результатами.
     */
    public int[] nextGreaterElement(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];

        // Инициализация массива результатов значениями -1
        for (int i = 0; i < nums.length; i++) {
            result[i] = -1;
        }

        // Проход массива справа налево
        for (int i = nums.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && stack.peek() <= nums[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                result[i] = stack.peek();
            }
            stack.push(nums[i]);
        }

        return result;
    }

    /**
     * Метод для запуска тестовых случаев.
     *
     * @param args Аргументы командной строки (не используются).
     */
    public static void main(String[] args) {
        NextGreaterElement sp = new NextGreaterElement();

        // Тестовый случай 1
        int[] testArray1 = {4, 5, 2, 10, 8};
        int[] result1 = sp.nextGreaterElement(testArray1);
        System.out.println("Результат для {4, 5, 2, 10, 8}: ");
        for (int num : result1) {
            System.out.print(num + " ");
        }
        System.out.println(); // Переход на новую строку

        // Тестовый случай 2
        int[] testArray2 = {1, 3, 2, 4};
        int[] result2 = sp.nextGreaterElement(testArray2);
        System.out.println("Результат для {1, 3, 2, 4}: ");
        for (int num : result2) {
            System.out.print(num + " ");
        }
        System.out.println(); // Переход на новую строку
    }
}
