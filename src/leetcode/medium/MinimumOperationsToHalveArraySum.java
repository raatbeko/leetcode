package leetcode.medium;

import java.util.Comparator;
import java.util.PriorityQueue;

import static java.lang.Math.max;

public class MinimumOperationsToHalveArraySum {


    /**
     * Задача <b>2208. Minimum Operations to Halve Array Sum</b> <br>
     * Наткнулся на эту задачу делая ежедневные задачи <br>
     * Задача говорит найти количество шагов после которого сумма массива будет равна или меньше из начальной суммы массива <br>
     * До старта решать задачу с начала надо обдумать шаги решения.
     * <ol>
     *   <li> Самому найти ответ. Вспомнить все свои похожие задачи которые уже решил. Если нашел решение тогда приступить к решению.</li>
     *   <li> Если ни как нету ответа надо посмотреть раздел Topics там есть подсказка о том какие структуры данных использовать </li>
     *   <li> Дополнительно можно прочитать обсуждения иногда бывает там очень простым языком объясняют задачу </li>
     * </ol>
     *
     * В решении этой задачи я не знал в начале что делать. В Topics написано что PriorityQueue это решение. Я знал как оно работает и нашелся ответ сразу
     * <ul>
     *   <li><b>Время:</b> 209ms</li>
     *   <li><i>Память:</i> 59.96MB</li>
     * </ul>
     */
    public int halveArray(int[] nums) {
        //  Если длина массива равен одному там одно решение nums[0]/2 ответ 1
        if (nums.length == 1)
            return 1;

        // нам нужна переменная для общей суммы
        double sum = 0;

        // нам нужна переменная для подсчета количество шагов
        int count = 0;

        // нам нужна переменная для суммы половины суммы это sum/2
        double halfSum;

        // нам нужна переменная для подсчета суммы когда мы делаем операцию
        double currentSum = 0;

        // нам нужно инициализировать doubles где Comparator будет сортировать от большего к меньшему по сути это не сорт а просто первый элемент он будет держать всегда самый большой
        PriorityQueue<Double> doubles = new PriorityQueue<>(Comparator.reverseOrder());

        //добавляем элементы массива в очередь одновременна считая сумму
        for (int num : nums) {
            sum += num;
            doubles.add((double) num);
        }
        // тут мы инициализируем переменную как положено;
        halfSum = sum / 2;

        // тут мы даем начальное значение и оно будет меняться по ходу дела
        currentSum = sum;

        // цикл пока очередь не пуст
        while (!doubles.isEmpty()) {
            // сразу счет на плюс 1 если он зашел значит одно операция гарантируется
            count++;

            // берем самый большой элемент и удаляем его и очереди
            Double poll = doubles.poll();

            // тут делим его на 2 как указано в задаче
            poll = poll / 2;

            // и минусуем от общей суммы. Из начально это число было за плюсована в эту переменную и как бы мы минусуем только его половину
            currentSum -= poll;

            // главное условие если дошли до суммы где он меньше или равно возвращаем count
            if (currentSum <= halfSum) return count;

            // иначе добавляем в очередь полученную сумму
            doubles.add(poll);
        }

        // фактически этот код никогда не отработает так как строка 73 говорит что doubles не когда не будет пустым))
        return count;
    }

    /**
     * Задача <b>3066. Minimum Operations to Exceed Threshold Value II</b>
     * самого начала я хотел решить эту задачу но увидел что вторая а первую я еще не решал <b>2208. Minimum Operations to Halve Array Sum</b> <br>
     * Условия задачи
     * <p> Вернуть количество шагов после которого все элементы массива будут равны или больше числу <b>k</b>
     * дана формула min(x, y) * 2 + max(x, y)
     * мы должны будем удалить элементы x y и добавить новое полученное значение в массив и повторять все пока не придем к нужному ответу </p>
     *
     * Найти ответ трудности не составило после решения задачи 2208
     * <p>
     * <ul>
     *   <li><b>Время:</b> 159ms</li>
     *   <li><i>Память:</i> 71.30MB</li>
     * </ul>
     */
    public int minOperations(int[] nums, int k) {

        // инициализируем очередь и передаем Comparator от меньшего к большому
        PriorityQueue<Long> longs = new PriorityQueue<>(Comparator.naturalOrder());

        // добавляем все элементы массива в очередь
        for (int num : nums) {
            longs.add((long) num);
        }

        // создаем переменную для подсчета количества
        int count = 0;

        // будем проходиться по циклу пока значение первого числа в очереди меньше k если первое число будет равен или больше нам уже будет понятно что все остальные числа попадают в это же условие
        while (longs.peek() < k) {
            // берем первый элемент
            Long x = longs.poll();

            // берем второй элемент
            Long y = longs.poll();

            // добавляем полученную сумму
            longs.add(x * 2 + y);

            // увеличиваем количество на 1
            count++;
        }
        return count;
    }

    public static void main(String[] args) {
        MinimumOperationsToHalveArraySum obj = new MinimumOperationsToHalveArraySum();
        System.out.println(obj.minOperations(new int[]{1, 1, 2, 4, 9}, 20));
    }
}
